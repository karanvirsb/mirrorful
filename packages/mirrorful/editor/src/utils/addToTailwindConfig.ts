import fs from 'fs'
import { readdir, readFile, writeFile } from 'fs/promises'
import path from 'path'

const tokens = ['colors', 'fontSizes', 'boxShadows']

export async function addToTailwindConfig() {
  const rootPath =
    process.env.NODE_ENV === 'development'
      ? '../tailwind.config.js'
      : '../../../tailwind.config.js'

  const IS_TAILWIND_BEING_USED = fs.existsSync(rootPath)
  // TODO check if tokens exist in tailwind;
  if (!IS_TAILWIND_BEING_USED) return
  const tokenInserts = {
    colors: '\t\t\t\t...mirrorful.Tokens.colors,',
    fontSize: '\t\t\t\t...mirrorful.Tokens.fontSizes,',
    dropShadow: '\t\t\t\t...mirrorful.Tokens.boxShadows,',
  }

  const tailwindInserts = {
    colors: `\t\t\tcolors: {\n${tokenInserts['colors']}\n\t\t\t},`,
    fontSize: `\t\t\tfontSize: {\n${tokenInserts['fontSize']}\n\t\t\t},`,
    dropShadow: `\t\t\tdropShadow: {\n${tokenInserts['dropShadow']}\n\t\t\t},`,
  }

  const SHOULD_UPDATE_TAILWIND_CONFIG = await shouldUpdateTailwindConfig({
    keys: tokens,
    path: path.join(__dirname, rootPath),
  })

  if (!SHOULD_UPDATE_TAILWIND_CONFIG) return

  try {
    const mirrorfulFolderPath = await getFolderPath({
      folderName: '.mirrorful',
    })

    let tailwindFile = await readFile(path.join(__dirname, rootPath), 'utf8')
    const hasColors = tailwindFile.match(/colors:(\s|^\s)(\{|\n)/)
    const hasFontSizes = tailwindFile.match(/fontSize:(\s|^\s)(\{|\n)/)
    const hasFontWeights = tailwindFile.match(/fontWeight:(\s|^\s)(\{|\n)/)
    const hasDropShadow = tailwindFile.match(/dropShadow:(\s|^\s)(\{|\n)/)

    // opening up extends brackets
    tailwindFile = tailwindFile.replace(/{}/g, '{\n}')

    const tailwindFileArr = tailwindFile.split('\n')

    let extendIndex =
      tailwindFileArr.findIndex((t) => t.includes('extend:')) + 1
    const colorsIndex = hasColors
      ? tailwindFileArr.findIndex((t) => t.includes('colors:')) + 1
      : -1
    let fontSizeIndex = hasFontSizes
      ? tailwindFileArr.findIndex((t) => t.includes('fontSize:')) + 1
      : -1
    const fontWeightIndex = hasFontWeights
      ? tailwindFileArr.findIndex((t) => t.includes('fontWeight:')) + 1
      : -1
    let dropShadowIndex = hasDropShadow
      ? tailwindFileArr.findIndex((t) => t.includes('dropShadow:')) + 1
      : -1

    if (hasColors) {
      tailwindFileArr.splice(colorsIndex, 0, tokenInserts['colors'])
      fontSizeIndex++
      dropShadowIndex++
    } else {
      tailwindFileArr.splice(extendIndex, 0, tailwindInserts['colors'])
      extendIndex++
    }

    if (hasFontSizes) {
      tailwindFileArr.splice(fontSizeIndex, 0, tokenInserts['fontSize'])
      dropShadowIndex++
    } else {
      tailwindFileArr.splice(extendIndex, 0, tailwindInserts['fontSize'])
      extendIndex++
    }

    if (hasDropShadow) {
      tailwindFileArr.splice(dropShadowIndex, 0, tokenInserts['dropShadow'])
    } else {
      tailwindFileArr.splice(extendIndex, 0, tailwindInserts['dropShadow'])
      extendIndex++
    }
    // TODO find where mirrorful is located
    let mirrorfulImport = ''
    if (!tailwindFile.includes('.mirrorful/theme_cjs.js')) {
      mirrorfulImport = `const mirrorful = require('${mirrorfulFolderPath}/theme_cjs.js')\n`
    }
    await writeFile(
      path.join(__dirname, rootPath),
      mirrorfulImport + tailwindFileArr.join('\n'),
      'utf-8'
    )
  } catch (error) {
    console.error(error)
  }
}
/**
 *
 * @param keys The tokens generated by mirrorful
 * @param path The path to the tailwind file
 * @returns Boolean
 */
async function shouldUpdateTailwindConfig({
  keys,
  path,
}: {
  keys: string[]
  path: string
}) {
  const tailwindFile = await readFile(path, 'utf-8')
  const booleanArr = []

  for (let i = 0; i < keys.length; i++) {
    const regex = `Tokens.${keys[i]}`
    booleanArr.push(tailwindFile.includes(regex))
  }

  return booleanArr.every((a) => a)
}

const skipDirs = [
  'node_modules',
  '.next',
  '.git',
  '.pnp',
  'coverage',
  'out',
  'build',
  'lib',
  '.vercel',
]
async function getFolderPath({ folderName }: { folderName: string }) {
  const rootDir = process.cwd()
  let finalPath = ''
  const queue = [...(await readdir(rootDir))]
  const visited = []

  while (queue.length > 0) {
    const folder = queue.shift()
    // if the next folder is empty quit
    if (folder === undefined) break
    // skip over the folders that most likely do not contain the folder
    if (skipDirs.includes(folder)) {
      visited.push(folder)
      continue
    }

    // if the path is a folder then check for the name
    if (fs.lstatSync(folder).isDirectory()) {
      if (folder.includes(folderName)) {
        finalPath = folder
        break
      }
      visited.push(folder)
      queue.push(
        ...(await readdir(path.join(rootDir, folder))).map(
          (path) => `${folder}/${path}`
        )
      )
    }
  }

  if (finalPath.length < 0) {
    throw Error(`Could not find the ${folderName} folder!`)
  }

  return './' + finalPath
}
